
HTTP 메소드

클라이언트가 서버에 “무엇을 어떻게 해달라”라고 의도를 전달하는 표준화된 방법이다. 좋은 API는 URI로는 리소스를 식별하고, 메소드를 통해 행위를 구분한다.


## 1) 왜 HTTP 메소드를 쓰는가
API URI 설계에서 “리소스 식별과 행위 분리”하기 위함이다. 예를 들어, 회원 목록 조회를 /read-member-list, 회원 등록을 /create-member와 같이 설계할 수 있지만, 이는 좋은 URI 설계 방법이 아니다. 좋은 URI는 리소스 식별이 잘 돼야 하며, 등록/수정하는 행위가 아니라 '바우처' 또는 '회원' 자체가 리소스이다. 따라서 행위를 배제하고 리소스만 남기게 되는데 (ex. /members, /members/{id}) 이렇게 될 경우에는 URI가 중복되는 문제가 발생할 수 있어 HTTP 메소드를 URI에 붙여 리소스와 행위를 분리할 수 있다. `GET /members`, `POST /members`처럼 URI는 리소스만, 메소드는 행위를 맡게 하면 일관성과 확장성이 좋아진다. 이런 제약을 따르는 스타일을 흔히 REST 아키텍처 스타일이라 부른다.

**학습 메모**
> 왜 중간에 REST를 설명하는 걸까?
> - URI는 리소스를, 메소드는 행위를 담당한다는 분리 원칙이 REST의 핵심 제약과 연결되기 때문.

## 2) 주요 HTTP 메소드

### GET — 조회
- 목적: 리소스의 표현을 조회한다.
- 특징: 안전하고 멱등적이며, 캐시가 용이하다. 일반적으로 본문을 사용하지 않는다(쿼리 스트링 사용).
- 예: `GET /members?active=true&page=1` → 목록 조회

### POST — 생성/처리 트리거
- 목적: 서버 측에서 “새 리소스 생성” 혹은 “처리(프로세스) 실행”을 트리거한다.
- 특징: 안전하지 않으며 멱등적이지 않은 경우가 대부분이고, 캐시하기 어렵다.
- 언제 프로세스에 쓰나? 단순 필드 변경이 아니라 비즈니스 전이를 유발할 때. 예: 주문의 상태가 `결제완료 → 배송시작 → 배송완료`로 진행되는 워크플로 트리거, 결제 승인 처리 등. 이 경우 결과로 새 리소스가 생기지 않을 수도 있다.
- 예: `POST /orders`(주문 생성), `POST /orders/123/ship`(배송 시작 트리거)

### PUT — 전체 치환(있으면 교체, 없으면 생성)
- 목적: 목적 리소스의 모든 현재 표시를 요청 페이로드(요청의 본문(Body) 부분에 담기는 정보)로 대체한다.
- 특징: 멱등적이다(같은 요청 반복 시 결과가 같다). 클라이언트가 대상의 식별자(위치)를 지정한다.
- 주의: 불완전한 데이터로 요청 시 기존 필드 값이 null로 변경될 수 있다.
- 예: `PUT /members/10` + 전체 멤버 JSON → 해당 멤버 전체 교체

### PATCH — 부분 수정
- 목적: 대상 리소스의 일부만 변경한다.
- 특징: 멱등일 수도, 아닐 수도 있다. “값 설정(set)”은 멱등, “누적/추가(add)”는 비멱등이 될 수 있다.
- 서버가 PATCH를 지원하지 않으면 POST로 대체하기도 한다.
- 예: `PATCH /members/10` + `{ "nickname": "yoon" }`

**학습 메모**
> 이전 프로젝트에서 부분 수정도 POST로 했던 이유가 뭘까? 
> - 주된 이유는 서버가 PATCH를 지원하지 않을 때다. 이 경우 POST 메소드를 사용하게 된다. 웬만한 것은 대부분 POST로 할 수 있기 때문이다. 그렇다면 PATCH 메소드의 캐시 기능 속성도 POST 메소드가 지원될까? PATCH와 POST 모두 캐시 가능 속성을 가지긴 하지만 결과적으로는 어렵다. POST 역시 리소스를 변경하는 요청이거나 (안전하지 않음), 요청 데이터를 처리하는 것이 주 목적이며, 캐시 키 고려 문제 때문에 조회 및 캐싱이 어렵기 때문이다.

### DELETE — 삭제
- 목적: 대상 리소스를 삭제한다.
- 특징: 멱등적이다(여러 번 호출해도 삭제된 상태는 동일). 일반적으로 본문이 없다.
- 예: `DELETE /members/10`

## 3) 기타 메소드
- HEAD: GET과 동일하되 본문 없이 헤더만 반환(메타데이터 확인, 캐시 검증 용도).
- OPTIONS: 대상 리소스/서버가 지원하는 메소드를 질의. 브라우저의 CORS 사전 요청(preflight)에 사용.
- CONNECT: 터널을 맺는다(주로 프록시를 통한 TLS 터널링).
- TRACE: 메시지 루프백 테스트(보안상 비활성화하는 경우 많음).

### 용어 정리
- 목적 리소스: 해당 요청의 대상이 되는 리소스(URI로 식별되는 대상).

**학습 메모**
> “목적 리소스”가 정확히 뭘 의미하지?
> - 요청이 작용하는 대상 리소스(URI로 지정된 것).

## 4) 메소드 속성 요약

### 안전성(Safe)
- 의미: 호출해도 서버 리소스의 상태를 바꾸지 않는다.
- 안전: GET, HEAD

**학습 메모**
> “안전”이 정확히 무슨 뜻이야?
> - GET 요청은 사용자가 인지하지 못하는 사이에 노출되거나 날아갈 수 있다. (예: 링크 클릭만으로도 요청이 발생할 수 있음). 만약 GET이 안전하지 않은 메서드로 구현되어 리소스의 상태를 바꿀 수 있다면, 사용자가 의도하지 않았는데도 자원이 변경될 위험이 있다. 따라서 안전한 메소드는 리소스에 변화가 없기 때문에 안전하다고 표현된다.

### 멱등성(Idempotent)
- 의미: 같은 요청을 여러 번 보내도 의도된 결과가 동일하다.
- 멱등: GET, PUT, DELETE
- 비멱등: POST
- 경우에 따라: PATCH(설정형은 멱등, 누적형은 비멱등)

**학습 메모**
> PATCH도 멱등해야 하지 않나? 언제 비멱등이지?
> - 특정 값으로 “설정”은 멱등, “추가/누적”은 비멱등이 될 수 있음. (본문 반영)

### 캐시 가능성(Cacheable)
- 표준상: GET, HEAD, POST, PATCH가 캐시 가능하다.
- 실무상: 주로 GET/HEAD만 캐시한다(POST/PATCH는 캐시 키/부작용 문제로 어려움).

## 5) 실무 가이드
- 조회는 GET: `GET /members`, `GET /members/{id}`
- 생성은 POST: `POST /members`
- 전체 교체는 PUT: `PUT /members/{id}` (누락 필드가 덮어써질 수 있음)
- 부분 수정은 PATCH: `PATCH /members/{id}`
- 삭제는 DELETE: `DELETE /members/{id}`
- 비즈니스 전이/프로세스 트리거는 POST 하위 리소스로 표현: `POST /orders/{id}/pay`, `POST /orders/{id}/ship`


