# RESTful이란 무엇인가?

## 1. REST API의 정의 및 명칭

REST(Representational State Transfer) 아키텍처 스타일의 설계 원칙을 따르는 애플리케이션 프로그래밍 인터페이스(API)이다.

## 2. REST API의 배경 및 본질

REST는 2000년에 컴퓨터 과학자 로이 필딩(Roy Fielding) 박사가 그의 박사 논문에서 정의한 개념이다. 그리고 프레임워크가 아닌 디자인 원칙(Design Principle) 또는 스타일 가이드라인이다. 프레임워크는 정해진 규율을 따르지 않으면 작동하지 않지만, REST API는 규범적이지 않으면서도 특정 규칙을 지키면 REST API라고 불릴 수 있게 된다. 이러한 특성 덕분에 REST는 개발자에게 높은 자유도를 보장해 주며, 어떤 프로그래밍 언어를 쓰든지 상관이 없고, 다양한 데이터 형식을 지원한다.

## 3. REST의 핵심 설계 원칙(제약 조건)

### 1. 클라이언트-서버 분리 (Client-Server Separation)
클라이언트와 서버 애플리케이션은 서로 완전히 독립적이어야 합니다. 클라이언트는 리소스의 URI만 알면 되고, 서버는 요청된 데이터를 HTTP를 통해 클라이언트에 전달하는 것 외에는 클라이언트를 수정해서는 안 된다.

### 2. 무상태 (Statelessness)
REST API는 무상태성을 가지며, 각 요청에는 처리에 필요한 모든 정보가 포함되어야 합니다. 서버 측 세션이 필요 없으며, 서버 애플리케이션은 클라이언트 요청과 관련된 데이터를 저장할 수 없다. 그리고 디버깅에도 유리하다.

### 3. 균일한 인터페이스 (Uniform Interface)
동일한 리소스에 대한 모든 API 요청은 요청의 출처에 관계없이 동일하게 보여야 한다. 균일한 인터페이스는 네 가지 하위 제약 조건으로 구성된다.

#### 3-1. 자원의 식별
서버의 개별 자원에 대해 언제나 변하지 않는 고유한 식별자로 URI를 사용해야 한다.

#### 3-2. 표현을 통한 자원의 조작
자원의 현재 상태를 특정 형식(JSON, XML)으로 표현하고 이 표현을 클라이언트와 서버가 서로 전송하여 자원의 상태를 전송하는 것이다.

#### 3-3. 자기 기술적인 메시지
클라이언트와 서버 사이를 오가는 메시지(요청 및 응답)는 그 자체로 스스로에 대해 충분히 설명할 수 있어야 한다.

#### 3-4. HATEOAS (Hypermedia as the Engine of Application State)
하이퍼미디어를 통해 클라이언트가 애플리케이션의 상태를 변경할 수 있는 인터페이스를 제공해야한다.

#### 3-5. 캐시 가능성
클라이언트나 서버 측에서 리소스를 캐시할 수 있어야 한다.

#### 3-6. 계층화된 시스템 아키텍처
클라이언트와 서버 애플리케이션이 서로 직접 연결된다고 가정하지 않는다. 통신 루프에는 프록시와 같은 다양한 중개자가 있을 수 있으며, 클라이언트나 서버는 자신이 최종 애플리케이션과 통신하는지 중개자와 통신하는지 알 수 없도록 설계해야 한다.

## 4. REST API의 구현 및 활용

### CRUD 작업과 HTTP 메서드
REST API는 HTTP 요청을 통해 통신하며 **CRUD(Create, Read, Update, Delete)**와 같은 표준 데이터베이스 기능을 수행한다. 예를 들어, GET 요청은 레코드를 검색하고, POST 요청은 새 레코드를 생성하며, PUT 요청은 기존 레코드를 업데이트하고, DELETE 요청은 레코드를 삭제합니다.

### URI 설계 원칙
URI를 설계할 때는 리소스에 대한 작업을 나타내는 **동사(Verb) 대신 명사(Noun)**를 기반으로 해야 합니다. 어떤 종류의 작업을 하는지는 HTTP 메서드(POST, GET 등)로 표현한다.

## 5. 실질적인 RESTful API 디자인 모범 사례

### 5.1 리소스 URI 정의 (명사 중심)
자원 중심 설계, 리소스 URI를 정의할 때 리소스에 대한 작업을 나타내는 명사를 기반으로 해야한다. (어떤 종류의 작업을 하는지는 HTTP 메서드로 표현되기에), 컬렉션을 참조하는 URI에는 일반적으로 복수 명사 사용, 컬렉션과 항목에 대한 URI를 계층 구조로 구성, 리소스 간의 관계를 표현하기 위해 하위 리소스 사용 가능(예: /customers/5/orders는 고객 5의 모든 주문)

### 5.2 HTTP 요청 메서드 사용 (CRUD 작업)
> **참고**: 자세한 HTTP 메서드 설명은 [HTTP 메소드.md](./HTTP%20메소드.md) 파일을 참고하세요.

### 5.3 데이터 표현 및 상태 코드

#### 데이터 형식
리소스 표현은 JSON, XML, HTML, 일반 텍스트 등 모든 형식으로 클라이언트에 전달될 수 있지만 JSON은 사람과 기계 모두 읽기 쉽고 프로그래밍 언어에 구애받지 않아 널리 사용된다.

#### 상태 코드
서버의 응답에는 요청을 처리한 결과를 명확히 나타내는 HTTP 상태 코드가 담겨야 한다.

- **200번대**: 성공적인 요청
- **400번대**: 클라이언트 측의 문제
- **500번대**: 서버 측의 문제로 인한 오류

## 6. REST 외의 다른 API 통신 방식들

REST API를 공부하다 보면 자연스럽게 "다른 API 통신 방식은 뭐가 있을까?"라는 궁금증이 생긴다. 특히 마이크로서비스 아키텍처가 대세가 되면서, 서비스 간 통신에서 더 높은 성능과 효율성을 요구하는 상황들이 많아졌다. 

### 6.1 REST의 한계점
- **성능**: HTTP/1.1 기반으로 인한 지연 시간
- **데이터 효율성**: JSON 텍스트 형식으로 인한 오버헤드
- **실시간 통신**: 단방향 요청-응답 모델의 한계
- **타입 안정성**: 런타임에만 오류를 발견할 수 있음

### 6.2 다양한 API 통신 방식 탐색
이런 한계점들을 해결하기 위해 개발자들은 다양한 대안들을 찾아보기 시작했다. 그 중에서 주목받는 기술 중 하나가 바로 gRPC이다.

## 7. gRPC란 무엇인가?

gRPC는 구글 내부에서 마이크로 서비스들이 통신하기 위해 내부적으로 사용하던 기술을 오픈소스로 공개한 것이다. 이를 사용하는 대표적인 회사로는 넷플릭스가 있다.

### gRPC의 핵심 기술
넷플릭스는 주로 다루는 데이터가 비디오 스트리밍이므로 데이터 효율이 매우 중요하다.

#### HTTP/2 기반
- 단일 TCP 연결을 사용하여 요청/응답 다중화를 가능하게 한다
- 통신 지연이 적고, 헤더 압축 기능을 통해 페이로드 크기를 크게 줄여 오버헤드를 줄이는데 기여한다

#### 프로토콜 버퍼 (Protocol Buffers)
- 데이터를 직렬화할 때 이진 형식을 사용
- HTTP/2 계층에서 데이터가 이진으로 캡슐화 및 인코딩된다
- 따라서 높은 성능을 달성할 수 있다

## 8. REST API와 gRPC 비교

| 비교 항목 | REST API (RESTful API) | gRPC (gRPC Remote Procedure Calls) |
|----------|----------------------|-----------------------------------|
| **설계 철학 및 성격** | 디자인 원칙(Design Principle) 또는 스타일 가이드라인. 느슨한 규범과 구현 방식의 다양성 제공. | RPC(원격 프로시저 호출) 프레임워크. 구글이 내부 마이크로 서비스용으로 개발한 기술. 엄격한 규범과 세세한 요구 사항을 따름. |
| **기반 프로토콜** | 주로 HTTP/1.1 프로토콜 기반. | HTTP/2 프로토콜 기반. |
| **데이터 형식/직렬화** | 주로 JSON이나 XML과 같은 텍스트 기반 형식 사용. 이는 처리 속도가 느리고 공간을 더 많이 차지함. | **프로토콜 버퍼(Protobuf)**를 사용하여 데이터를 이진 형식으로 직렬화. 이진 형식은 효율적이고 압축된 JSON보다 우수해야 함. |
| **성능 및 효율성** | HTTP/1.1을 사용하면 지연 시간(Latency)이 높을 수 있음. | 고성능을 위해 설계됨. Protobuf와 HTTP/2 덕분에 일반적으로 더 빠르고 효율적임. 네트워크 처리량 및 지연 시간 측면에서 이점을 가짐. |
| **통신 스타일** | 전통적인 요청-응답 모델. | **다중화(Multiplexed)**를 지원하여 단일 TCP 연결로 여러 요청을 주고받을 수 있음. 양방향 스트리밍 (Bidirectional Streaming) 지원. |
| **인터페이스 정의 (계약)** | 프로토콜이나 API 문서에 의존하며, 프로토 파일 계약은 선택 사항임. | 프로토콜 버퍼를 **IDL(Interface Definition Language)**로 사용하여 무조건 프로토 파일로 계약을 맺어야 함. protoc 컴파일러를 통해 코드가 생성됨. |
| **리소스 모델** | 자원(Resource) 중심 (명사 기반 URI). HTTP 메서드 (GET, POST, PUT, DELETE 등)를 사용하여 리소스에 대한 CRUD 작업을 정의. | 함수 호출 기반(RPC). 클라이언트가 마치 로컬 객체처럼 서버의 메서드를 직접 호출함. |
| **캐싱** | HTTP 헤더(Header)를 사용하여 캐싱을 지원하며, 이는 확장성과 성능에 도움이 됨. | 내장된 캐싱 메커니즘이 없음. 외부 도구나 라이브러리를 사용해야 함. |
| **브라우저 호환성** | HTTP 기반이므로 웹 브라우저에서 광범위하게 호환됨. | HTTP/2 사용으로 인해 브라우저에서 직접 구현이 불가능하며, 클라이언트 구현을 위해 프록시가 필요함. |
| **주요 사용 사례** | CRUD 작업을 수행하는 표준 웹 API, 공용 API, 단순성과 광범위한 호환성이 중요할 때. | 마이크로서비스 아키텍처 내의 서비스 간 통신, 실시간 통신이나 높은 성능 및 데이터 효율성이 필요할 때. |
| **보안 (암호화)** | 일반적으로 HTTPS를 사용하여 통신을 암호화함. | 기본적으로 SSL/TLS를 사용하여 클라이언트와 서버 간 통신을 암호화함. |