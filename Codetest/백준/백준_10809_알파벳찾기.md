# 백준 10809 - 알파벳 찾기

## 문제 해결 과정

### 1. 입력 방법 비교

#### Scanner vs BufferedReader

**Scanner 사용법:**
```java
Scanner scanner = new Scanner(System.in);
String word = scanner.nextLine();
int n = scanner.nextInt();
```

**Scanner의 특징:**
- 형 변환까지 자동으로 해주고, 공백 단위로 쉽게 나눠준다
- **단점**: 
  - 내부적으로 정규식으로 입력을 파싱하기 때문에 느리다
  - 대량의 입력을 다루는 경우 시간 초과가 날 수 있다
- **결론**: 편하지만 느리다

**BufferedReader 사용법:**
```java
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String word = reader.readLine();
int n = Integer.parseInt(reader.readLine()); // 숫자일 경우 직접 변환해줘야 함
```

**BufferedReader의 특징:**
- 입력을 버퍼(buffer)에 저장했다가 한번에 처리하기 때문에 빠르다
- **단점**: 
  - 읽은 건 전부 문자열(String)이기에 숫자를 입력받을 때는 직접 변환해줘야 한다

#### 여러 값을 한 줄에서 받는 방법

**split() 사용:**
```java
String[] values = reader.readLine().split(" ");
int a = Integer.parseInt(values[0]);
int b = Integer.parseInt(values[1]);
```

**StringTokenizer 사용:**
```java
StringTokenizer tokenizer = new StringTokenizer(reader.readLine()); // 속도는 split(" ")보다 빠르다
int a = Integer.parseInt(tokenizer.nextToken());
int b = Integer.parseInt(tokenizer.nextToken());
```

### 2. String vs Char 사용 이유

**다른 사람들의 풀이 중 핵심 코드:**
```java
for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);  // i번째 문자 꺼내기
    int idx = c - 'a';     // 해당 문자를 a=0~z=25로 변환
    if (arr[idx] == -1) {  // 처음 나온 문자라면
        arr[idx] = i;      // 그 위치 기록
    }
}
```

**Char를 사용하는 이유:**
- Char를 사용해서 문자를 숫자처럼 다루기 위함
- 유니코드(문자의 숫자 코드 값)을 활용
- 이를 통해 배열의 인덱스처럼 다룰 수 있다

## 학습 포인트

1. **입력 방법 선택**: 대량의 입력이 예상되면 BufferedReader 사용
2. **문자 처리**: ASCII/유니코드 값을 활용한 효율적인 문자 처리
3. **배열 인덱싱**: 문자를 숫자로 변환하여 배열 인덱스로 활용하는 기법
